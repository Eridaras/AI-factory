#!/usr/bin/env node

/**
 * MCP Server: Feature Replicator
 * 
 * Escanea repositorios legacy y extrae especificaciones detalladas de funcionalidades
 * para poder replicarlas en nuevos proyectos.
 * 
 * Capacidades:
 * - Listar todas las funcionalidades detectadas en un repo
 * - Analizar a fondo cada feature (BD, tablas, columnas, rutas, APIs, reglas)
 * - Generar especificaciones en JSON y Markdown
 */

import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from "@modelcontextprotocol/sdk/types.js";
import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

// Obtener __dirname en ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Configuraci√≥n de logging
const LOG_FILE = path.join(__dirname, "feature-replicator.log");

/**
 * Logger para el servidor MCP
 */
function log(message) {
  const timestamp = new Date().toISOString();
  const logLine = `[${timestamp}] ${message}\n`;
  
  try {
    fs.appendFileSync(LOG_FILE, logLine);
  } catch (err) {
    // Silenciar errores de logging para no romper MCP
  }
}

log("MCP Feature Replicator Server iniciando...");

/**
 * Helper: Cargar configuraci√≥n de tecnolog√≠as soportadas
 */
function loadTechConfig() {
  const configPath = path.join(__dirname, "tech-stack-config.json");
  
  try {
    const content = fs.readFileSync(configPath, "utf8");
    const config = JSON.parse(content);
    log(`Tech config loaded: ${Object.keys(config.supported_languages).length} languages`);
    return config;
  } catch (error) {
    log(`Warning: Could not load tech-stack-config.json: ${error.message}`);
    return { supported_languages: {}, supported_databases: {} };
  }
}

const TECH_CONFIG = loadTechConfig();

/**
 * Helper: Cargar tech stack desde auditor√≠a previa
 */
function loadTechStack(repoPath) {
  const statusPath = path.join(repoPath, "docs", "TECH_STACK_STATUS.json");
  
  if (!fs.existsSync(statusPath)) {
    log(`Tech stack file not found: ${statusPath}`);
    return {};
  }
  
  try {
    const content = fs.readFileSync(statusPath, "utf8");
    const stack = JSON.parse(content);
    log(`Tech stack loaded: ${stack.language}/${stack.framework}`);
    return stack;
  } catch (error) {
    log(`Error loading tech stack: ${error.message}`);
    return {};
  }
}

/**
 * Helper: Validar entrada
 */
function validateInput(inputName, value, type, options = {}) {
  if (value === undefined || value === null) {
    if (options.required !== false) {
      throw new Error(`Missing required input: ${inputName}`);
    }
    return options.default;
  }
  
  // Validaci√≥n de tipos
  if (type === "string" && typeof value !== "string") {
    throw new Error(`Invalid input type for ${inputName}: expected string, got ${typeof value}`);
  }
  
  if (type === "number" && typeof value !== "number") {
    throw new Error(`Invalid input type for ${inputName}: expected number, got ${typeof value}`);
  }
  
  if (type === "array" && !Array.isArray(value)) {
    throw new Error(`Invalid input type for ${inputName}: expected array, got ${typeof value}`);
  }
  
  // Validaciones de rango para n√∫meros
  if (type === "number") {
    if (options.min !== undefined && value < options.min) {
      throw new Error(`${inputName} must be >= ${options.min}`);
    }
    if (options.max !== undefined && value > options.max) {
      throw new Error(`${inputName} must be <= ${options.max}`);
    }
  }
  
  return value;
}

/**
 * Helper: Buscar archivos recursivamente con filtro de extensiones
 */
function findFiles(dirPath, extensions, maxFiles = 1000) {
  const results = [];
  
  function scanDir(currentPath, depth = 0) {
    if (results.length >= maxFiles || depth > 10) return;
    
    try {
      const entries = fs.readdirSync(currentPath, { withFileTypes: true });
      
      for (const entry of entries) {
        if (results.length >= maxFiles) break;
        
        const fullPath = path.join(currentPath, entry.name);
        
        // Ignorar directorios comunes
        if (entry.isDirectory()) {
          const ignoreDirs = ['node_modules', 'bin', 'obj', '.git', '.vs', 'packages', 'vendor', '__pycache__'];
          if (!ignoreDirs.includes(entry.name)) {
            scanDir(fullPath, depth + 1);
          }
        } else if (entry.isFile()) {
          const ext = path.extname(entry.name).toLowerCase();
          if (extensions.includes(ext)) {
            results.push(fullPath);
          }
        }
      }
    } catch (error) {
      log(`Error scanning directory ${currentPath}: ${error.message}`);
    }
  }
  
  scanDir(dirPath);
  return results;
}

/**
 * Helper: Detectar features en un repo C#
 */
function detectCSharpFeatures(repoPath, files) {
  const features = [];
  const controllerFiles = files.filter(f => f.includes('Controller') && f.endsWith('.cs'));
  
  let featureIndex = 1;
  
  for (const controllerFile of controllerFiles) {
    try {
      const content = fs.readFileSync(controllerFile, 'utf8');
      const relativePath = path.relative(repoPath, controllerFile);
      
      // Extraer nombre del controller
      const controllerMatch = content.match(/class\s+(\w+Controller)/);
      const controllerName = controllerMatch ? controllerMatch[1] : path.basename(controllerFile, '.cs');
      
      // Detectar actions (m√©todos p√∫blicos con [HttpGet], [HttpPost], etc. o que retornan ActionResult)
      const actionMatches = content.matchAll(/public\s+(?:async\s+)?(?:Task<)?(?:ActionResult|IActionResult|JsonResult|ViewResult)[^{]+\s+(\w+)\s*\(/g);
      const actions = [...actionMatches].map(m => m[1]);
      
      // Buscar archivos relacionados (services, repositories)
      const baseName = controllerName.replace('Controller', '');
      const relatedFiles = [relativePath];
      
      // Buscar service
      const serviceFile = files.find(f => f.includes(`${baseName}Service`) && f.endsWith('.cs'));
      if (serviceFile) {
        relatedFiles.push(path.relative(repoPath, serviceFile));
      }
      
      // Buscar repository
      const repoFile = files.find(f => f.includes(`${baseName}Repository`) && f.endsWith('.cs'));
      if (repoFile) {
        relatedFiles.push(path.relative(repoPath, repoFile));
      }
      
      const featureId = `LEGACY-F-${String(featureIndex).padStart(3, '0')}`;
      featureIndex++;
      
      features.push({
        id: featureId,
        name: baseName.replace(/([A-Z])/g, ' $1').trim(),
        summary: `Controller con ${actions.length} actions detectadas${actions.length > 0 ? ': ' + actions.slice(0, 3).join(', ') : ''}`,
        main_files: relatedFiles,
        metadata: {
          controller: controllerName,
          actions: actions.slice(0, 10),
          language: 'csharp',
          framework: 'aspnet-mvc'
        }
      });
      
    } catch (error) {
      log(`Error processing controller ${controllerFile}: ${error.message}`);
    }
  }
  
  return features;
}

/**
 * Helper: Detectar features seg√∫n el lenguaje
 */
async function detectFeatures(repoPath, tech_stack, maxFiles) {
  const language = tech_stack.language || 'unknown';
  const langConfig = TECH_CONFIG.supported_languages[language];
  
  if (!langConfig) {
    log(`Warning: Language '${language}' not configured in TECH_CONFIG`);
    return [];
  }
  
  log(`Detecting features for language: ${language}`);
  
  // Buscar archivos con las extensiones del lenguaje
  const extensions = langConfig.extensions || [];
  const files = findFiles(repoPath, extensions, maxFiles);
  
  log(`Found ${files.length} files with extensions: ${extensions.join(', ')}`);
  
  // Detectar features seg√∫n el lenguaje
  let features = [];
  
  switch (language) {
    case 'csharp':
      features = detectCSharpFeatures(repoPath, files);
      break;
      
    // TODO: Implementar otros lenguajes
    case 'java':
    case 'php':
    case 'python':
    case 'javascript':
    case 'typescript':
      log(`Language ${language} detection not yet implemented`);
      break;
      
    default:
      log(`Unknown language: ${language}`);
  }
  
  return features;
}

/**
 * Tool: list_features
 * Escanea el repositorio y devuelve una lista de funcionalidades detectadas
 */
async function listFeatures(args) {
  const repoPath = validateInput("path", args.path, "string", { default: "." });
  const tech_stack = args.tech_stack || loadTechStack(repoPath);
  const max_files = validateInput("max_files", args.max_files, "number", { 
    default: 300, 
    min: 1, 
    max: 5000 
  });
  
  log(`list_features called: path=${repoPath}, max_files=${max_files}, stack=${JSON.stringify(tech_stack)}`);
  
  try {
    // Verificar que el path existe
    if (!fs.existsSync(repoPath)) {
      throw new Error(`Repository path does not exist: ${repoPath}`);
    }
    
    // Detectar features bas√°ndose en el tech stack
    const features = await detectFeatures(repoPath, tech_stack, max_files);
    
    log(`list_features completed: ${features.length} features found`);
    
    return {
      features,
      tech_stack,
      scanned_path: repoPath,
      total_files_scanned: max_files
    };
    
  } catch (error) {
    log(`ERROR en list_features: ${error.message}`);
    throw error;
  }
}

/**
 * Tool: scan_feature
 * Analiza a fondo una funcionalidad y extrae especificaci√≥n completa
 */
async function scanFeature(args) {
  const feature_id = validateInput("feature_id", args.feature_id, "string");
  const entry_files = validateInput("entry_files", args.entry_files, "array");
  const repoPath = validateInput("path", args.path, "string", { default: "." });
  const tech_stack = args.tech_stack || loadTechStack(repoPath);
  const max_depth = validateInput("max_depth", args.max_depth, "number", {
    default: 4,
    min: 1,
    max: 10
  });
  
  log(`scan_feature called: feature_id=${feature_id}, entry_files=${entry_files.length}, max_depth=${max_depth}`);
  
  try {
    // Validar que los archivos existen
    const validFiles = [];
    for (const file of entry_files) {
      const fullPath = path.join(repoPath, file);
      if (fs.existsSync(fullPath)) {
        validFiles.push({ relative: file, full: fullPath });
      } else {
        log(`WARNING: Entry file not found: ${fullPath}`);
      }
    }
    
    if (validFiles.length === 0) {
      throw new Error("No valid entry files found");
    }
    
    // Analizar features seg√∫n el lenguaje
    const language = tech_stack.language || 'csharp';
    let spec;
    
    switch (language) {
      case 'csharp':
        spec = await analyzeCSharpFeature(feature_id, validFiles, repoPath, tech_stack, max_depth);
        break;
        
      // TODO: Otros lenguajes
      default:
        spec = createBasicSpec(feature_id, validFiles, tech_stack);
    }
    
    log(`scan_feature completed: ${spec.files_involved.length} files analyzed`);
      feature_id,
      name: "Nombre de la funcionalidad extra√≠da",
      domain_purpose: "Descripci√≥n del prop√≥sito de negocio de esta funcionalidad",
      inputs: [
        {
          name: "parametro1",
          type: "string",
          description: "Descripci√≥n del par√°metro"
        }
      ],
      outputs: [
        {
          type: "json",
          description: "Objeto con la respuesta"
        }
      ],
      data_sources: [
        {
          kind: "database",
          engine: tech_stack.databases?.[0]?.engine || "sql_server",
          database: tech_stack.databases?.[0]?.name || "DATABASE_NAME",
          schema: "dbo",
          table: "TableName",
          columns: ["Column1", "Column2", "Column3"],
          filters: "WHERE Column1 = @param1",
          joins: "LEFT JOIN OtherTable ON ...",
          source_code_snippet: "SELECT Column1, Column2 FROM TableName WHERE Column1 = @param1"
        }
      ],
      file_system: [
        {
          kind: "network_share",
          path_pattern: "\\\\SERVER\\Share\\Reports\\report_{date}.xlsx",
          operation: "read"
        }
      ],
      external_services: [
        {
          kind: "api_call",
          url_or_host: "https://api.example.com/endpoint",
          method: "POST",
          payload_example: '{"field": "value"}'
        }
      ],
      business_rules: [
        "Validar que el usuario tenga permisos",
        "Solo mostrar registros activos",
        "Aplicar filtro por fecha"
      ],
      files_involved: entry_files,
      tech_stack
    };
    
    log(`scan_feature completed: ${spec.files_involved.length} files analyzed`);
    
    return spec;
    
  } catch (error) {
    log(`ERROR en scan_feature: ${error.message}`);
    throw error;
  }
}

/**
 * Tool: export_feature_markdown
 * Genera un archivo Markdown con la especificaci√≥n detallada
 */
async function exportFeatureMarkdown(args) {
  const feature_spec = validateInput("feature_spec", args.feature_spec, "object");
  const output_path = validateInput("output_path", args.output_path, "string");
  
  log(`export_feature_markdown called: output_path=${output_path}`);
  
  try {
    // Crear directorio si no existe
    if (!fs.existsSync(output_path)) {
      fs.mkdirSync(output_path, { recursive: true });
      log(`Created output directory: ${output_path}`);
    }
    
    // Generar nombre de archivo
    const fileName = `${feature_spec.feature_id || "feature"}_${(feature_spec.name || "spec")
      .replace(/\s+/g, "_")
      .replace(/[^a-zA-Z0-9_]/g, "")}.md`;
    
    const filePath = path.join(output_path, fileName);
    
    // Generar contenido Markdown
    const md = `# ${feature_spec.name || "Funcionalidad"}

**ID:** ${feature_spec.feature_id || "N/A"}

---

## üìã Prop√≥sito de negocio

${feature_spec.domain_purpose || "Sin descripci√≥n disponible"}

---

## üì• Entradas

${feature_spec.inputs && feature_spec.inputs.length > 0 
  ? feature_spec.inputs.map(inp => `- **${inp.name}** (${inp.type}): ${inp.description || "Sin descripci√≥n"}`).join("\n")
  : "Sin entradas definidas"}

---

## üì§ Salidas

${feature_spec.outputs && feature_spec.outputs.length > 0
  ? feature_spec.outputs.map(out => `- **Tipo:** ${out.type}\n  - ${out.description || "Sin descripci√≥n"}`).join("\n\n")
  : "Sin salidas definidas"}

---

## üóÑÔ∏è Fuentes de datos

${feature_spec.data_sources && feature_spec.data_sources.length > 0
  ? feature_spec.data_sources.map(ds => `
### ${ds.engine} - ${ds.database || "N/A"}.${ds.schema || "N/A"}.${ds.table}

**Columnas:** ${ds.columns ? ds.columns.join(", ") : "N/A"}

${ds.filters ? `**Filtros:** \`${ds.filters}\`` : ""}
${ds.joins ? `**Joins:** \`${ds.joins}\`` : ""}

${ds.source_code_snippet ? `**Query:**\n\`\`\`sql\n${ds.source_code_snippet}\n\`\`\`` : ""}
  `).join("\n---\n")
  : "Sin fuentes de datos definidas"}

---

## üìÅ Sistema de archivos

${feature_spec.file_system && feature_spec.file_system.length > 0
  ? feature_spec.file_system.map(fs => `
- **Tipo:** ${fs.kind}
- **Patr√≥n:** \`${fs.path_pattern}\`
- **Operaci√≥n:** ${fs.operation}
  `).join("\n")
  : "Sin operaciones de sistema de archivos"}

---

## üåê Servicios externos

${feature_spec.external_services && feature_spec.external_services.length > 0
  ? feature_spec.external_services.map(svc => `
### ${svc.kind}

- **URL/Host:** \`${svc.url_or_host}\`
- **M√©todo:** ${svc.method}

${svc.payload_example ? `**Payload de ejemplo:**\n\`\`\`json\n${svc.payload_example}\n\`\`\`` : ""}
  `).join("\n---\n")
  : "Sin servicios externos"}

---

## ‚öñÔ∏è Reglas de negocio

${feature_spec.business_rules && feature_spec.business_rules.length > 0
  ? feature_spec.business_rules.map(rule => `- ${rule}`).join("\n")
  : "Sin reglas de negocio documentadas"}

---

## üìÑ Archivos involucrados

${feature_spec.files_involved && feature_spec.files_involved.length > 0
  ? feature_spec.files_involved.map(file => `- \`${file}\``).join("\n")
  : "Sin archivos documentados"}

---

## üîß Stack t√©cnico

${feature_spec.tech_stack ? `
- **Lenguaje:** ${feature_spec.tech_stack.language || "N/A"}
- **Framework:** ${feature_spec.tech_stack.framework || "N/A"}
- **Bases de datos:** ${feature_spec.tech_stack.databases ? feature_spec.tech_stack.databases.map(db => `${db.engine} (${db.name})`).join(", ") : "N/A"}
` : "Sin informaci√≥n de stack t√©cnico"}

---

*Documento generado autom√°ticamente por feature-replicator MCP*
`;
    
    // Escribir archivo
    fs.writeFileSync(filePath, md, "utf8");
    
    log(`Markdown exported successfully: ${filePath}`);
    
    return {
      file_path: filePath,
      file_name: fileName,
      success: true
    };
    
  } catch (error) {
    log(`ERROR en export_feature_markdown: ${error.message}`);
    throw error;
  }
}

// Crear servidor MCP
const server = new Server(
  {
    name: "feature-replicator",
    version: "1.0.0",
  },
  {
    capabilities: {
      tools: {},
    },
  }
);

// Registrar handler para listar tools
server.setRequestHandler(ListToolsRequestSchema, async () => {
  log("ListTools request received");
  
  return {
    tools: [
      {
        name: "list_features",
        description: "Escanea el repositorio legacy y devuelve una lista de funcionalidades detectadas (endpoints, casos de uso, jobs, etc.) bas√°ndose en el tech stack.",
        inputSchema: {
          type: "object",
          properties: {
            path: {
              type: "string",
              description: "Ruta ra√≠z del repositorio a escanear",
              default: "."
            },
            tech_stack: {
              type: "object",
              description: "Informaci√≥n del stack tecnol√≥gico (opcional, se lee de TECH_STACK_STATUS.json si no se proporciona)",
              properties: {
                language: {
                  type: "string",
                  description: "Lenguaje principal (csharp, java, node, python, etc.)"
                },
                framework: {
                  type: "string",
                  description: "Framework usado (aspnet-mvc, spring, express, django, etc.)"
                },
                databases: {
                  type: "array",
                  items: { type: "string" },
                  description: "Lista de motores de BD (sap_hana, sql_server, postgresql, etc.)"
                }
              }
            },
            max_files: {
              type: "number",
              description: "L√≠mite de archivos a escanear (1-5000)",
              default: 300,
              minimum: 1,
              maximum: 5000
            }
          },
          required: ["path"]
        }
      },
      {
        name: "scan_feature",
        description: "Analiza a fondo una funcionalidad espec√≠fica y extrae TODA la informaci√≥n necesaria para replicarla: BD, tablas, columnas, queries, rutas de archivos, APIs externas, reglas de negocio, etc.",
        inputSchema: {
          type: "object",
          properties: {
            feature_id: {
              type: "string",
              description: "ID √∫nico de la funcionalidad (ej: LEGACY-F-001)"
            },
            entry_files: {
              type: "array",
              items: { type: "string" },
              description: "Archivos principales que implementan esta funcionalidad"
            },
            path: {
              type: "string",
              description: "Ruta ra√≠z del repositorio",
              default: "."
            },
            tech_stack: {
              type: "object",
              description: "Stack tecnol√≥gico (opcional)",
              properties: {
                language: { type: "string" },
                framework: { type: "string" },
                databases: { 
                  type: "array",
                  items: { type: "string" }
                }
              }
            },
            max_depth: {
              type: "number",
              description: "Profundidad m√°xima de seguimiento de llamadas (1-10)",
              default: 4,
              minimum: 1,
              maximum: 10
            }
          },
          required: ["feature_id", "entry_files"]
        }
      },
      {
        name: "export_feature_markdown",
        description: "Genera un archivo Markdown con la especificaci√≥n completa y legible de una funcionalidad, listo para que humanos e IAs lo usen como contrato de implementaci√≥n.",
        inputSchema: {
          type: "object",
          properties: {
            feature_spec: {
              type: "object",
              description: "Objeto de especificaci√≥n devuelto por scan_feature"
            },
            output_path: {
              type: "string",
              description: "Directorio donde guardar el archivo .md (ej: docs/FEATURES_SPEC)"
            }
          },
          required: ["feature_spec", "output_path"]
        }
      }
    ]
  };
});

// Registrar handler para llamadas a tools
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;
  
  log(`Tool invoked: ${name}`);
  log(`Arguments: ${JSON.stringify(args)}`);
  
  try {
    let result;
    
    switch (name) {
      case "list_features":
        result = await listFeatures(args);
        break;
        
      case "scan_feature":
        result = await scanFeature(args);
        break;
        
      case "export_feature_markdown":
        result = await exportFeatureMarkdown(args);
        break;
        
      default:
        throw new Error(`Unknown tool: ${name}`);
    }
    
    log(`Tool ${name} completed successfully`);
    
    return {
      content: [
        {
          type: "text",
          text: JSON.stringify(result, null, 2)
        }
      ]
    };
    
  } catch (error) {
    log(`ERROR en tool ${name}: ${error.message}`);
    throw error;
  }
});

// Iniciar servidor
async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  log("MCP Feature Replicator Server conectado y listo");
}

main().catch((error) => {
  log(`ERROR FATAL: ${error.message}`);
  process.exit(1);
});
